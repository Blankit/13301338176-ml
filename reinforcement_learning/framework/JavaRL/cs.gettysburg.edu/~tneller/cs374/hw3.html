<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 12.0">
   <title>Homework #3</title>
</head>
<body>
<table WIDTH="100%" >
<tr>
<td><img SRC="GburgCS.gif" height=84 width=182></td>

<td><font size=+2>CS 3</font><font size="5">74 Compilers<br></font><font size=+2>
Homework #3</font></td>
</tr>
</table>

<hr>
<b>Due: Tuesday 2/14 at the beginning of class</b><ul>
  <li><b>Test cases: </b>3 text files with valid MiniJava programs, and 5 text 
  files with MiniJava programs with syntax errors.&nbsp; E-mail these text files as attachments to class mailing list<a href="mailto:GBC_CS_374_A_SPRING_2012@cnav.gettysburg.edu">
  </a>GBC_CS_374_A_SPRING_2012@cnav.gettysburg.edu), by<b> Friday 2/10.</b></li>
</ul>
<p><b>Note: </b>This work is to be done in <b>assigned groups</b>.&nbsp; Each group will submit one assignment.&nbsp; Although 
you may divide the work, both team members should be able to present/describe 
their partner's work upon request.&nbsp; 
<p><b>0. Preparation:&nbsp; </b>There are no files to download for this 
exercise.&nbsp; You'll simply be extending your work from the previous exercise.&nbsp; 
Read Appendix Section A.2, the MiniJava grammar.&nbsp; You may find it useful to 
have the <a href="https://javacc.dev.java.net/doc/docindex.html">online JavaCC 
documentation</a> available during development.</p>

<p><b>1. Eliminating Left Recursion:&nbsp;</b> You'll note that the MiniJava grammar 
production for <i>Exp</i> is left-recursive.&nbsp; Rewrite <i>Exp </i>such that 
it is not left-recursive.&nbsp;&nbsp; This can be done in two ways.</p>

<p><b><u>General Process:</u>&nbsp; </b>This is described on pp. 51-52 of 
the text, and involves significant restructuring of the grammar and the 
introduction of a single new production (e.g. <i>ExpPrime</i>). The downside to 
this technique is that it does nothing to address issues of operator precedence 
and associativity.&nbsp; All proper structuring of the abstract syntax tree is 
deferred to the next stage.&nbsp; Although not required, you should should 
probably consider the following option. </p>

<p><b><u>Precedence Hierarchy Process:</u>&nbsp;</b> Since our left recursion results from our 
expressions, we can also eliminate left recursion by establishing a <i>hierarchy 
of expressions </i>according to operator precedence.&nbsp; An example of this 
can be seen in transformation of text grammar 3.5 to one similar to text grammar 
3.8.&nbsp; In grammar 3.5, the left recursion results from the binary operator.&nbsp; 
The operators &quot;*&quot; and &quot;/&quot; take precedence over (i.e. bind more tightly than) the 
operators &quot;+&quot; and &quot;-&quot;.&nbsp; </p>

<p>We can thus transform</p>

<pre>E -> id 
   | num 
   | E ( * | / | + | - ) E 
   | "(" E ")"
</pre>
to
<pre>E -> T ( ( + | - ) T )*
T -> F ( ( * | / ) F )*
F -> id 
   | num 
   | "(" E ")"
</pre>
Here, E stands for Expression, T stands for Term, and F stands for Factor.&nbsp;
While this does not address the issue of operator associativity, it does address the issue of operator precedence and eliminates left recursion.

For our MiniJava grammar, the original Exp production is given as:
<pre>Exp     -> Exp op Exp
        -> Exp "[" Exp "]"
        -> Exp . length
        -> Exp . id "(" ExpList ")"
        -> INTEGER_LITERAL
        -> true
        -> false
        -> id
        -> this
        -> new int "[" Exp "]"
        -> new id "(" ")"
        -> ! Exp
        -> "(" Exp ")"
</pre>
The first four productions are responsible for the left-recursion.&nbsp;
Operator precedence (high to low) according to Java's specification is:
<pre>Exp[Exp]        Exp.length      Exp.id(ExpList) 
!Exp            new Exp()       new int[Exp]
Exp * Exp
Exp + Exp       Exp - Exp
Exp < Exp
Exp && Exp
</pre>
Operators on the same line have the same precedence.  Following the previous example and the 
<a href="examples/ch03/JavaCCJavaGrammars/Java1.2-a.jj">example JavaCC grammar for Java 1.2</a>, we can thus rewrite our MiniJava grammar according to 
this more complex precedence hierarchy:
<pre>Exp             -> And
And             -> LessThan ( && LessThan )*
LessThan        -> AdditiveExp [ < AdditiveExp ]
AdditiveExp     -> Times ( ( + | - ) Times )*
Times           -> PrefixExp ( "*" PrefixExp )*
PrefixExp       -> Not | PostfixExp
Not             -> ( ! )+ PostfixExp
PostfixExp      -> PrimaryExp ( "[" Exp "]" 
                                | . id "(" ExpList ")" 
                                | . length )*
PrimaryExp      -> INTEGER_LITERAL
                -> true
                -> false
                -> id
                -> this
                -> "(" Exp ")"
                -> new int "[" Exp "]"
                -> new id "(" ")"
</pre>
Again, while this does address operator precedence, this does not
address the issue of operator associativity.  This can be handled in the next phase when
we construct the abstract syntax tree.

<p>Whichever method you choose,

<b>be sure to document your grammar transformations well in your README file.</b>
</p>

<p><b>2. JavaCC Grammar:&nbsp;</b> Translate your transformed grammar to JavaCC.&nbsp; 
At the end of your lexical analysis file, begin adding your productions as follows:</p>

<pre>void Program() :
{}
{
        MainClass() ( ClassDecl() )*
}

void MainClass() :
{}
{
        &lt;CLASS&gt; &lt;IDENTIFIER&gt; &lt;LBRACE&gt; &lt;PUBLIC&gt; &lt;STATIC&gt; &lt;VOID&gt; &lt;MAIN&gt; &lt;LPAREN&gt; &lt;STRING&gt; &lt;LSQPAREN&gt; &lt;RSQPAREN&gt; &lt;IDENTIFIER&gt; &lt;RPAREN&gt; 
                &lt;LBRACE&gt; Statement() &lt;RBRACE&gt; &lt;RBRACE&gt;
}

...
</pre>


<p>Hint: Although there is no epsilon, you may make a part of a production 
optional using square brackets.<br>
&nbsp;</p>


<p>You may look to the <a href="examples/ch03/JavaCCJavaGrammars">example JavaCC 
Java grammars</a> for guidance, but you may not use anything you don't 
understand.&nbsp; For example, the inclusion of additional Java structures 
beyond the MiniJava specification will be considered plagiarism and violation of 
the honor code.&nbsp; Again, <b>do not use what you do not understand.&nbsp; </b>
It's also better that you do not copy and paste.&nbsp; The experience of 
constructing the grammar yourself is not to be underestimated.&nbsp; Use the 
example grammar only when you get stuck.</p>


<p>When you've completed this translation, you should be able to generate your 
parser with the command <tt>javacc</tt> <i>although you will probably have choice 
conflict warnings.</i></p>


<p><b>3. Resolving Choice Conflicts:&nbsp; </b>Resolve each conflict 
sequentially, using the LOOKAHEAD facility of javacc.&nbsp; At this point, you 
should study the <a href="https://javacc.dev.java.net/doc/lookahead.html">JavaCC LOOKAHEAD MiniTutorial</a> in depth.&nbsp; For each choice conflict,</p>

<ul>
  <li><b>Understand the conflict. </b>&nbsp;What is the ambiguity that makes the 
  recursive-descent parser unable to figure out which choice to make at a choice 
  point?&nbsp; To do this, you might imagine yourself as the parser, and come up 
  with a concrete example of the ambiguity.</li>
  <li><b>Determine what information is needed to resolve the conflict.</b>&nbsp; 
  How far ahead would you need to look in example to see which way parsing 
  should proceed?&nbsp; Is it a set number of tokens, or does it involve 
  identifying grammar constructions? From the concrete example, generalize what 
  information is needed looking ahead before the correct choice can be 
  determined.</li>
  <li><b>Use the appropriate LOOKAHEAD form to provide this information.&nbsp;
  </b>For our purposes, do not worry about the computational expense of 
  significant backtracking.&nbsp; It's more important for us to keep our grammar 
  as close to the original as possible.</li>
</ul>

<p>&nbsp;<b>4. Testing: </b>&nbsp;Download 
<a href="http://us.cambridge.org/features/052182060X/index.html#Progs">MiniJava example programs
</a>and test 
them to see that they successfully parse.&nbsp; Note: At this point, we're not 
actually building the abstract syntax tree.&nbsp; We're looking for a successful 
match to (parse with) our grammar.&nbsp; Create 3 additional correct MiniJava programs, and 5 additional incorrect MiniJava programs that should yield syntax 
errors.&nbsp; Verify that these are processed correctly and give appropriate 
output.<br>
</p>

<h3>Supplemental Chapter Comments</h3>

<p>(These comments are to supplement your reading.&nbsp; Question(s) asked are for 
you to think about on your own and need not be turned in with the homework.)</p>
<p><b>3.0: </b>Give special attention to this preamble before section 3.1.&nbsp; 
It provides a good explanation of the limitations of the expressiveness of 
regular expressions.&nbsp; Understanding the difference between regular 
expressions and context-free grammars will give you a clearer sense of the 
division between lexical and syntactic analysis.&nbsp; You should carry around 
in your mind at least one simple context-free grammar that cannot be expressed 
using regular expressions.&nbsp; What is your favorite example?<br>
<br>
<b>3.1:</b> As with regular expressions, context-free grammars are covered in CS 
301, but are essential for you to understand for our purposes.&nbsp; Give 
special attention to this section, as you will be writing a context-free grammar 
to parse a subset of Java (MiniJava).&nbsp; Much of your project work will be 
based on traversals and transformation of tree data structures which correspond 
to parse trees.</p>
<p><b>3.2: </b>This material is parallel to the material to the finite automata 
material of the previous chapter, in that it gives a deeper understanding of the 
output of various parser generators.&nbsp; This is <i>especially</i> important 
when is comes time to disambiguate an ambiguous grammar.&nbsp; Often, parsing 
tools that encounter an ambiguity will report the ambiguity <i>using the 
terminology of the underlying parsing algorithm.</i>&nbsp; For example, a 
reported &quot;shift/reduce conflict&quot; from yacc would be utterly incomprehensible 
without understanding the underlying mechanism being created (see Section 3.3).&nbsp; 
Since JavaCC is an LL(k) parser generator, it is important to understand this 
section well and then skim the <a href="https://javacc.dev.java.net/doc/lookahead.html">JavaCC LOOKAHEAD MiniTutorial</a>.&nbsp; This tutorial will help you resolve one lookahead complication in the LL(k) parsing of MiniJava.</p>
<p><b>3.3:</b>&nbsp; It is unclear whether or not we will have time to cover 
this section in class.&nbsp; If you are possibly interested in going to graduate 
school, I strongly recommend gaining a solid understanding of all of this 
material.&nbsp; Also, both yacc and bison, the most common C parser generators, 
and SableCC for Java generate LALR(1) parsers described in this section.&nbsp; 
Thus, you should seek to understand shift-reduce and reduce-reduce conflicts if 
you wish to be able to resolve them in the future.&nbsp; It is worthwhile 
material.</p>
<p><b>3.4: </b>&nbsp;Read about JavaCC and again look at JavaCC usage examples 
we have on our system (<tt>/usr/share/javacc/examples</tt>).&nbsp; 
Ignore the SableCC material.&nbsp; </p>
<p><b>3.5:&nbsp; </b>This reading is optional, but interesting.&nbsp; 
Programmers often complain about error-reporting in compilers, but look at the 
problem from the compiler writer's perspective!</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body></html>