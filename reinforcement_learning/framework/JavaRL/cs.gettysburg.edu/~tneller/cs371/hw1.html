<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 12.0">
   <meta name="Author" content="Todd Neller">
   <title>Homework #1</title>
</head>
<body bgcolor="#FFFFFF">
&nbsp;
<table WIDTH="100%" >
<tr>
<td><img SRC="GburgCS.gif" height=84 width=182></td>

<td><font size=+2>CS 371 - Introduction to Artificial Intelligence</font>
<br><font size=+2>Homework #1</font></td>
</tr>
</table>

<hr>
<br><b>Due: Thursday 2/2 at the beginning of class.&nbsp; Include a README file 
with the honor pledge, your names and student IDs.</b><br><b>Note: Work is to be done in pairs 
unless otherwise approved.</b><h1>
<b>Uninformed Search</b></h1>
<p>
0. Reading, Starter Code, Peg Solitaire, and the Buckets Problem:&nbsp; Read 
R&amp;N Chapter 3 through section 3.4.5.&nbsp; Download and 
study the supplied
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/">
starter code</a> (<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/doc/">documentation</a>).&nbsp; 
Read more about the Peg Solitaire and Buckets problems
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/">
here</a>.&nbsp; Give special attention to the implementation of
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/PegSolitaireNode.java">
PegSolitaireNode</a> and
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/BucketsNode.java">
BucketsNode</a>, as these will serve as models for a
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/SearchNode.java">
SearchNode</a> you will extend later.</p>
<p>
1. <strong>Breadth-First Search</strong>: Complete the implementation of the Breadth-First Search 
(BFS) class
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/BreadthFirstSearcher.java">
BreadthFirstSearcher</a> by filling in code after the given comments (in-class).&nbsp; 
Node children should enter the queue in the same order that they appear in the 
list returned by the expand method.&nbsp; With this and other search algorithms 
to come, test your implementation with both
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/PegSolitaireNode.java">
PegSolitaireNode</a> and
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/BucketsNode.java">
BucketsNode</a> by uncommenting the appropriate lines in
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/SearchTest.java">
SearchTest</a>.</p>
<p>
2. <strong>Depth-First Search</strong>: Complete the implementation of the Depth-First Search 
(DFS) class
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/code/java1.5update/DepthFirstSearcher.java">
DepthFirstSearcher</a> by filling in code after the given comments (in-class).&nbsp; 
Node children should be pushed onto the stack in the same order that they appear 
in the list returned by the expand method. </p>
<p>
3. <strong>Depth-Limited Search</strong>: Implement Depth-Limited Search (DLS) class DepthLimitedSearcher by 
modifying your DepthFirstSearcher to take an integer depth limit as the single 
contructor parameter, and not expanding/pushing nodes beyond the depth limit.&nbsp; </p>
<p>
4. <strong>Iterative-Deepening Depth-First Searc</strong>h: Implement Iterative-Deepening 
Depth-First Search (IDDFS) class IterativeDeepeningDepthFirstSearcher by 
creating a new Searcher class extension that performs depth-limited searches to 
depth limits 1, 2, 3, etc. until successful.&nbsp; Remember that the node count 
of this Searcher is the sum of the node counts of all depth-limited searches 
performed.</p>
<p>
5. <strong>Recursive Depth-First Search</strong>: In many applications of depth-first search, 
it is simpler to express it as a recursive algorithm.&nbsp; (Using a different 
model of a search node, this permits one to make/undo state changes easily.)&nbsp; 
Implement Search class extension RecursiveDepthFirstSearcher that performs a 
recursive depth-first search of each child in the order that they appear in the 
list returned by the expand method.&nbsp; Note that this implementation 
effectively visits a node's children in the <em>reverse</em> order that they 
would be visited in the iterative stack-based implementation of DepthFirstSearcher. </p>
<p>
6. <strong>Designing a Reverse-Perfect-Shuffle Magic Trick</strong>: Implement class ReversePerfectShuffleNode according to 
<a href="reversePerfectShuffleDoc/ReversePerfectShuffleNode.html">this specification</a>.
Read the comments with great care to understand the specification of each 
Searcher method.&nbsp; In addition, you will add a main method that prints the 
results of a search, revealing the means to perform a card magic trick of my 
design.<p>ReversePerfectShuffleNode is a class modeling perfect reverse (a.k.a. anti-faro) in- and out-shuffles in order to find a means of working the four top cards into the 5th, 10th, 15th, and 20th positions. 
A perfect shuffle is one where the deck is cut perfectly in half and then "riffled" together alternating one card from each half like the teeth of a zipper before being pushed together.  
This is considered to be one of the most difficult sleights of hand in card magic, and it allows the performer to control the positions of all cards in the deck, rearranging the permutation in unexpected ways.
There are two perfect shuffles that differ according to whether the first card down comes from the top or bottom half.
A perfect <b>out-shuffle</b> leaves the top card on top, that is, <b>outside</b> the deck.
A perfect <b>in-shuffle</b> leaves the top card at the second card, that is, <b>inside</b> the deck.
</p> 
<p>A reverse perfect shuffle is just the opposite. See <a href="http://cs.gettysburg.edu/~tneller/cs371/reversePerfectShuffle.pdf">Figure 3</a> from <a href="http://www.amazon.com/gp/product/0691151644/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0691151644&linkCode=as2&tag=towneho-20">Magical Mathematics: The Mathematical Ideas That Animate Great Magic Tricks</a> by Persi Diaconis and Ron Graham.
After alternating cards are separated into two halves, one half is placed atop 
the other.&nbsp; While perfect shuffles are one of the most difficult sleights of hand, this simple process of alternate up- and down-jogging of cards can be performed by most anyone.
As before, a reverse perfect <b>out-shuffle</b> leaves the top card on top, that is, <b>outside</b> the deck.
A reverse perfect <b>in-shuffle</b> leaves the top card right after the middle 
of the deck, that is, <b>inside</b> the deck.
</p>
<hr>
<p>
Quiz/exam preview: While not required for this homework, look at the written 
exercises at
<a href="http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/index.html">http://cs.gettysburg.edu/~tneller/resources/ai-search/uninformed-java/index.html</a> 
to get a sense of questions I commonly include on quizzes and exams.<p><a href="http://cs.gettysburg.edu/~tneller/">Todd Neller</a>
<br><img SRC="tneller-email.gif" height=20 width=143>
</body>
</html>