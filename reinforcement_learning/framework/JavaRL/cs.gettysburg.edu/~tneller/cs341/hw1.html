<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 12.0">
   <title>Homework #1</title>
   <link rel="icon" type="image/ico" href="http://cs.gettysburg.edu/~tneller/favicon.ico" />
   <link rel="shortcut icon" type="image/ico" href="http://cs.gettysburg.edu/~tneller/favicon.ico" />
   <style type="text/css">
   .style1 {
	   text-decoration: underline;
   }
   </style>
</head>
<body>
&nbsp;<table WIDTH="100%" >
<tr>
<td><img SRC="GburgCS.gif" height=84 width=182></td>

<td><font size=+2>CS 341 - Survey of Programming Languages</font>
<br><font size=+2>Homework #1</font></td>
</tr>
</table>

<hr>
<br><b>Due: 9/26 at the beginning of class #9</b>
<p><b>Note: </b>This work is to be done in <strong>assigned groups</strong>.&nbsp; Each 
group will submit one assignment.&nbsp; Although you may divide the work, each team member 
should be able to independently present/describe all submitted work upon 
request.&nbsp; 
<p>Submission: You will be emailed a set of test input files.&nbsp; By the due 
date/time, you should email with the following output files <strong>using these 
filenames</strong> from each of your 
programs as attachments:<ul>
	<li>max1000-out.txt (output of maximum given intList1000.txt)</li>
	<li>factorial10-out.txt (output of factorial given factorial10.txt)</li>
	<li>unique1000-out.txt (output of unique given intList1000.txt)</li>
	<li>quicksort1000-out.txt (output of quicksort given intList1000.txt)</li>
	<li>bst1000-out.txt (output of breadth first search given bst1000.txt)</li>
	<li>bfs1000-out.txt (output of best-first search given bfs1000.txt)</li>
</ul>
<h2>Learning Programming Language Basics</h2>
<p>For our 4th hour project this semester, you will be creating your own 
interpreted programming language.&nbsp; Before you create your language grammar, 
an important precursor step is to gain exposure to a variety of languages in 
order to inform you design.&nbsp; For this assignment, you will:</p>
<ul>
	<li>Implement 6 algorithms in a programming language <span class="style1">assigned to your group</span>.</li>
	<li>Schedule and hold an evening class meeting to informally present and discuss your 
	solutions, most least/favorite language features, etc.</li>
</ul>
<p>The 6 algorithms you will implement will be strictly and simply defined in a 
programming-contest-style input/output specification where input and output will 
consist of only one integer per line.&nbsp; These exercises range in difficulty 
from the level of a first introductory programming course to the level of a data 
structures course.&nbsp; For each exercise, you'll be provided with a single 
test input and solution output set of text files.&nbsp; <em>You should create 
and use additional tests.&nbsp; </em>Knowledge of Unix standard input/output 
redirection (&quot;&lt;&quot;/&quot;&gt;&quot;) and &quot;diff&quot; and &quot;wc&quot; commands will be helpful in your 
testing.&nbsp; It is also worth your while to create script files to somewhat 
automate your testing.&nbsp; Good testing is key.&nbsp; All test files below may 
be downloaded in a single .zip file <a href="exercises/all-files.zip">here</a>. </p>
<h3>Maximum</h3>
<p>Input: a positive integer <em>n</em>, followed by <em>n</em> integers a<sub>1</sub>, 
..., a<em><sub>n</sub></em>&nbsp; (E.g. <a href="exercises/int-list-in.txt">
int-list-in.txt</a>)<br>Output: the maximum of the <em>n</em> integers a<sub>1</sub>, 
..., a<sub><em>n</em></sub>&nbsp; (E.g. <a href="exercises/maximum-out.txt">
maximum-out.txt</a>)</p>
<h3>Factorial</h3>
<p>Input: a non-negative integer <em>n</em>&nbsp; (E.g. 
<a href="exercises/factorial-in.txt">factorial-in.txt</a>)<br>Output: <em>n</em> factorial, 
computed recursively&nbsp; (E.g. <a href="exercises/factorial-out.txt">
factorial-out.txt</a>)</p>
<h3>Unique</h3>
<p>Input: a positive integer <em>n</em>, followed by <em>n</em> integers a<sub>1</sub>, 
..., a<sub><em>n</em></sub>&nbsp; (E.g. <a href="exercises/int-list-in.txt">int-list-in.txt</a>)<br>Output: the unique integers of a<sub>1</sub>, 
..., a<sub><em>n</em></sub> ordered by first occurrence&nbsp; (E.g. 
<a href="exercises/unique-out.txt">unique-out.txt</a>)</p>
<h3>Quicksort</h3>
<p>Input: a positive integer <em>n</em>, followed by <em>n</em> integers a<sub>1</sub>, 
..., a<sub><em>n</em></sub>&nbsp; (E.g. <a href="exercises/int-list-in.txt">
int-list-in.txt</a>)<br>Output: the integers of a<sub>1</sub>, ..., a<sub><em>n</em></sub>, 
sorted with the <a href="ita3e-quicksort.pdf">quicksort algorithm of Introduction to Algorithms 3<sup>rd</sup> 
ed., by Cormen et al.</a>&nbsp; (E.g. <a href="exercises/quicksort-out.txt">
quicksort-out.txt</a>)</p>
<h3>Binary Search Tree</h3>
<p>Input: a sequence of integer pairs, one integer per line. The first integer 
of each pair will encode a binary tree operation (0=delete, 1=insert, 
2=contains). The second integer of each pair will be the integer key for the 
operation. After all pairs, a single value of -1 will indicate the end of input.&nbsp; (E.g. 
<a href="exercises/binary-search-tree-in.txt">binary-search-tree-in.txt</a>)<br>
Output: For each delete and contains operation, output 0/1 if the given value is 
not/is currently contained within the binary tree, respectively.&nbsp; (E.g. 
<a href="exercises/binary-search-tree-out.txt">binary-search-tree-out.txt</a>)<br>Note: The 
binary search tree implementation will be according to the 
<a href="ita3e-bst.pdf">binary search tree algorithms of 
Introduction to Algorithms 3<sup>rd</sup> ed., by Cormen et al</a>.</p>
<h3>Breadth-First Search</h3>
<p>Input: <br>- a positive integer <em>n</em>, indicating the number of graph 
nodes, indexed 0 through <em>n</em>-1<br>- pairs of node indices, one index per 
line, indicating an undirected edge between the indexed nodes<br>- a value of 
-1, indicating the end of the graph specification<br>- the start node index <em>
u</em><br>- the goal node index <em>v</em>&nbsp; (E.g. 
<a href="exercises/breadth-first-search-in.txt">breadth-first-search-in.txt</a>)<br>Output:<br>- a sequence of node 
integers, beginning with <em>u</em>, ending with <em>v</em>, defining a graph 
path from <em>u</em> to <em>v</em> computed with breadth-first search, or the 
single integer -1 if no such path exists&nbsp; (E.g. 
<a href="exercises/breadth-first-search-out.txt">breadth-first-search-out.txt</a>)<br>Note: The breadth-first search 
implementation will be according to the <a href="ita3e-bfs.pdf">breadth-first 
search algorithms of Introduction to Algorithms 
3<sup>rd</sup> ed., by Cormen et al.</a> and makes use of variable-length adjacency 
lists.</p>
<!--
<p>&nbsp;<p>DRAFT NOTE: The following will likely be split off into HW2<p>Read the <a href="scheme-intro/index.html">tutorial</a> up through 
&quot;Pairs and Lists&quot;, and complete the following
<a href="scheme-intro/exercises.html">companion exercises</a>:<p>REPL Exercises 
3-4<br>
Operators and Operands Exercises 2-4<br>
Identifiers, Whitespace, and Comments Exercise 3<br>
Fundamental Types Exercises 1-3, 6-7<br>
Pairs and Lists Exercises 3-6<br>
&nbsp;
-->
<h2>The Process of Learning Programming Language Basics</h2>
<p>With each of these problems approached in sequence, there is a natural 
progression of questions to answer with each.&nbsp; Here are some examples:</p>
<ul>
	<li>Maximum:<ul>
		<li>How do I write to standard output?</li>
		<li>How do I read from standard input?</li>
		<li>How do a declare/read/set a variable?</li>
		<li>How do I form basic decision (e.g. if-else) and iteration (e.g. 
		while) control constructs?</li>
	</ul>
	</li>
	<li>Factorial:<ul>
		<li>How do I define recursive functions (a.k.a. procedures, methods, 
		subroutines, subprograms, callable units)?</li>
	</ul>
	</li>
	<li>Unique:<ul>
		<li>How do I best represent sets?&nbsp; How do I add set members and 
		test set membership?</li>
	</ul>
	</li>
	<li>Quicksort:<ul>
		<li>How do I construct/read from/write to random access lists?</li>
	</ul>
	</li>
	<li>Binary Search Tree:<ul>
		<li>How do I construct objects or, alternatively, lists of heterogenous 
		data that contain object fields (a.k.a attributes, members, instance 
		variables).</li>
		<li>How do I get/set fields of such objects/lists?</li>
		<li>How do I assign object references, or do I need to simulate such 
		references using another technique, e.g. object array indices?</li>
	</ul>
	</li>
	<li>Breadth-First Search:<ul>
		<li>How do I dynamically add to variable length lists?</li>
	</ul>
	</li>
</ul>
<p>This is not an exhaustive list of questions, of course, but in them you can 
see a gradual, step-by-step formation of general-purpose programming competency.&nbsp; 
These tasks get you started with basics, forming a sort of &quot;<a href="https://en.wikipedia.org/wiki/Pidgin">pidgin</a>&quot; 
usage of the programming language but not necessarily providing understanding of 
important language idioms.&nbsp; For this reason, it is also important to study many 
good examples of programming idioms and express/apply them yourself to 
become truly fluent in a programming langauge.&nbsp; Expect each language to 
have strengths, specialty application areas, and stylistic merits that may not 
be obvious at first glance.&nbsp; If you seek to program every language in the 
style of Java programmers, you'll not only be unsatisfied with most everything 
but Java, but you'll also miss the beauty of other language design decisions and 
programming paradigms.</p>
<p>In approaching different programming languages, become like an international 
traveller that is able to become immersed in the culture to the point that there 
will be something missed and appreciated from each culture.&nbsp; For example, 
engage a functional programming language such as Scheme as Scheme programmers 
do, making liberal use of tail recursion and lesser use of loops, favoring 
thinking in terms of expression evaluation rather than statement execution, and 
you will grow to be a multi-paradigm programmer, able to discern the right 
programming approach to diverse problems.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body></html>