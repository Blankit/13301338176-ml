<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 12.0">
   <title>Homework #6</title>
   <style type="text/css">
.style1 {
	font-family: "Courier New", Courier, monospace;
}
</style>
</head>
<body>
&nbsp;<table WIDTH="100%" >
<tr>
<td><img SRC="GburgCS.gif" height=84 width=182></td>

<td><font size=+2>CS 341 - Survey of Programming Languages</font>
<br><font size=+2>Homework #6</font></td>
</tr>
</table>

<hr>
<p><B>Due: Tuesday 10/3 at the beginning of class #11</B></p>
<P><B>Note: </B>This work is to be done in <B>pairs</B>.&nbsp; Each pair will 
submit one assignment.&nbsp; Although you may divide the work, both team members 
should be able to present/describe their partner's work upon request.&nbsp;
<P>To submit this homework, change into the directory containing all necessary 
files: MiniScheme1.jj and supporting abstract syntax tree .java files, and enter 
the command &quot;<span class="style1">submit341 ms1</span>&quot;.<h1>MiniScheme Project 
Phase 1</h1>
<P>In this phase of the project, you will implement an interpreter for a very 
small initial subset of the MiniScheme language (which is in turn a subset of 
Scheme).&nbsp; This phase will implement simple I/O and simple integer 
expressions.<P>It is recommended that you begin with simple classes to represent 
an abstract syntax tree (AST) node, environment, and value-environment pair, 
such as <a href="minischeme/1">these</a>.&nbsp; You will add your own AST nodes 
for the more specific classes corresponding to grammar elements below.&nbsp; 
Your code should first parse the grammar into an AST, and then evaluate that AST 
(which in the future could mean that a node is visited for evaluation many 
times).<P>Specification:<ul>
	<li>The main interpreter method generated by MiniScheme1.jj will be in 
	MiniScheme1.java.&nbsp; Running &quot;java MiniScheme1 &lt;MiniScheme file&gt;&quot; should 
	interpret the given file &lt;MiniScheme file&gt; specified as a command-line 
	argument (i.e. args[0] in your MiniScheme1 main method), read input from standard input, 
	write output to standard output, and print error messages to standard error 
	(System.err).</li>
	<li>(newline) will print a newline to standard output.</li>
	<li>(read) will read a line from standard input, seek to parse it as an 
	integer, and evaluate the expression as that integer.&nbsp; If a non-integer 
	is entered, then the following message will be printed to the standard error 
	stream: &quot;read expects type &lt;integer&gt;, given: &quot; concatenated with the 
	non-integer input and a newline.&nbsp; In the event of such an error 
	execution exits (System.exit) with code 13.</li>
	<li>(write &lt;expression&gt;) will print the integer the expression evaluates to 
	standard output without a newline.&nbsp; As with Scheme, write returns an 
	unspecified value.&nbsp; (You may, for instance, return a null/void value, 
	but no code should rely on this value, including my test code.&nbsp; Trying 
	to do an operation with this return value should produce an error.)</li>
	<li>Integers are defined as in the R5RS Scheme standard and may include sign 
	and leading zeros.</li>
	<li>Predefined binary arithmetic procedures are plus (+), minus (-), times 
	(*) and integer division (quotient).&nbsp; It is recommended that you create 
	a single AST node for all arithmetic expressions, constructing each with the 
	operator token (+/-/*/quotient), and evaluating conditioned on the operator 
	token.</li>
	<li>A quotient of a number with zero should cause the standard error stream 
	message &quot;quotient: undefined for 0&quot; and an exit with code 2. </li>
	<li>If the first argument of a binary arithmetic procedure is not an 
	integer, print &quot;&lt;operator&gt;: expects type &lt;integer&gt; as 1st argument&quot; to 
	standard error, where &quot;&lt;operator&gt;&quot; is replaced by the given operator itself.&nbsp; 
	If the first argument is an integer, but the second is not, similarly print&nbsp; 
	&quot;&lt;operator&gt;: expects type &lt;integer&gt; as 2nd argument&quot;.&nbsp; In either error 
	case, exit with code 3.</li>
	<li>If write is given a non-integer value, similarly print &quot;write: expects 
	type &lt;integer&gt; as 1st argument&quot; and exit with code 3.</li>
	<li>After successful complete interpretation of standard input (including 
	I/O), execution exits with code 0.</li>
</ul>
<h2>Grammar</h2>
<p>Grammar notes:</p>
<ul>
	<li>Non-terminals are surrounded with angle brackets &quot;&lt;&quot; and &quot;&gt;&quot;.&nbsp; </li>
	<li>Terminals (e.g. &quot;(&quot; and &quot;)&quot; are represented as themselves without 
	quotes, unless otherwise noted below).</li>
	<li>--&gt; denotes a right arrow.&nbsp; Choices to the right of the arrow are 
	separated by a pipe (i.e. &quot;|&quot;).</li>
	<li>{ }* and { }+ denote a Kleene star and plus/cross, respectively. { }? 
	denotes an optional subexpression.</li>
</ul>
<p>&lt;program&gt; --&gt; { &lt;expression&gt; }*<br><br>&lt;expression&gt; --&gt; &lt;literal&gt;<br>| 
&lt;defined expression&gt;<br><br>&lt;literal&gt; --&gt; &lt;integer&gt;<br>&lt;integer&gt; --&gt; { + | - }? 
{ &lt;digit&gt; }+<br>&lt;digit&gt; --&gt; [0-9]<br><br>&lt;defined expression&gt; --&gt; ( read )<br>| ( write &lt;expression&gt; )<br>
| ( newline )<br>| ( + &lt;expression&gt; &lt;expression&gt; )<br>| ( - &lt;expression&gt; 
&lt;expression&gt; )<br>| ( * &lt;expression&gt; &lt;expression&gt; )<br>| ( quotient &lt;expression&gt; 
&lt;expression&gt; )</p>

</body></html>
